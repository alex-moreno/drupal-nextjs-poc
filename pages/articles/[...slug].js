import { NextSeo } from "next-seo";
import { isMultiLanguage } from "../../lib/isMultiLanguage";
import { fetchJsonapiEndpoint } from "@pantheon-systems/drupal-kit";
import {
  getCurrentLocaleStore,
  globalDrupalStateAuthStores,
} from "../../lib/drupalStateContext";

import Article from "../../components/article.js";
import Layout from "../../components/layout";

export default function ArticleTemplate({ title, body, imgSrc, hrefLang }) {
  return (
    <Layout>
      <NextSeo
        title="Decoupled Next Drupal Demo"
        description="Generated by create next app."
        languageAlternates={hrefLang}
      />
      <Article title={title} body={body} imgSrc={imgSrc} />
    </Layout>
  );
}

export async function getStaticPaths(context) {
  // TODO - locale increases the complexity enough here that creating a usePaths
  // hook would be a good idea.
  // Get paths for each locale.
  const pathsByLocale = context.locales.map(async (locale) => {
    const store = getCurrentLocaleStore(locale, globalDrupalStateAuthStores);

    const articles = await store.getObject({
      objectName: "node--article",
      query: `
          {
            id
            path {
              alias
            }
          }
        `,
    });
    return articles.map((article) => {
      // matches everything after /articles/
      const match = article.path.alias.match(/^\/articles\/(.*)$/);
      const slug = match[1];

      return { params: { slug: [slug] }, locale: locale };
    });
  });

  // Resolve all promises returned as part of pathsByLocale.
  const paths = await Promise.all(pathsByLocale).then((values) => {
    // Flatten the array of arrays into a single array.
    return [].concat(...values);
  });

  return {
    paths,
    fallback: false,
  };
}

export async function getStaticProps(context) {
  const { locales, locale } = context;
  const multiLanguage = isMultiLanguage(locales);
  const store = getCurrentLocaleStore(
    context.locale,
    globalDrupalStateAuthStores
  );
  store.params.clear();

  const slug = `/articles/${context.params.slug[0]}`;

  // if preview, use preview endpoint and add to store.
  if (context?.previewData?.key) {
    let requestInit = {};
    if (process.env.CLIENT_ID && process.env.CLIENT_SECRET) {
      requestInit = {
        headers: {
          Authorization: await store.getAuthHeader(),
        },
      };
    }
    const previewData = await fetchJsonapiEndpoint(
      `${store.apiRoot}decoupled-preview/${context.previewData.key}?include=field_media_image.field_media_image`,
      requestInit
    );
    if (previewData.errors) {
      throw previewData.errors[0].detail;
    }
    const uuid = previewData.data.id;

    store.setState({ "node--articleResources": { [uuid]: previewData } });
  }

  // if a revision, pass resourceVersion parameter.
  if (context?.previewData?.resourceVersionId) {
    store.params.addCustomParam({
      resourceVersion: `id:${context.previewData.resourceVersionId}`,
    });
  }
  store.params.clear();
  store.params.addInclude(["field_media_image.field_media_image"]);
  // If preview mode, get the preview data from the store, other wise fetch from the api.
  const article = await store.getObjectByPath({
    objectName: "node--article",
    // Prefix the slug with the current locale
    path: `${multiLanguage ? locale : ""}${slug}`,
    query: `
        {
          id
          title
          body
          path {
            alias
            langcode
          }
          field_media_image {
            field_media_image {
              uri {
                url
              }
            }
          }
        }
      `,
  });

  store.params.clear();

  const origin = process.env.NEXT_PUBLIC_FRONTEND_URL;
  // Load all the paths for the current article.
  const paths = locales.map(async (locale) => {
    const localeStore = getCurrentLocaleStore(
      locale,
      globalDrupalStateAuthStores
    );
    const { path } = await localeStore.getObject({
      objectName: "node--article",
      id: article.id,
    });
    return path;
  });

  // Resolve all promises returned as part of paths
  // and prepare hrefLang.
  const hrefLang = await Promise.all(paths).then((values) => {
    return values.map((value) => {
      return {
        hrefLang: value.langcode,
        href: origin + "/" + value.langcode + value.alias,
      };
    });
  });

  return {
    props: {
      title: article.title,
      body: article.body.value,
      imgSrc: article.field_media_image.field_media_image.uri.url,
      hrefLang,
      revalidate: 60,
    },
  };
}
